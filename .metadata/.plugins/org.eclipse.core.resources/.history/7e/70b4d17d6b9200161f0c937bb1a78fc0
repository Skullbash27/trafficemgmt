import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

public class TrafficPoint {
	
	private static HashMap<char[], TrafficPoint> trafficPoints = new HashMap<char[], TrafficPoint>();
	
	private Road street;
	private Road avenue;
	
	/*private static int greenTime = 5000;
	private static int yellowTime = 2000;
	private int sleepTime;*/
	
	private char[] pointID = new char[8];
	/*
	 * TrafficControl is a class to represent intersection points
	 * ID divided into two 4-char IDs
	 * first 4-chars [0:3] represents the street ID
	 * second 4-chars [4:7] represents the avenue ID
	 * first char of the road ID 1=entrance, 2=exit, 3=street, 4=avenue
	 */
	private char[] roadDir = new char[2];
	//first char street direction, second char avenue direction
	private int[] xy = new int[2];
	private char[] control = new char[2];
	/*
	 * first char street light status R=Red G=Green Y=Yellow
	 * second char avenue light status R=Red G=Green Y=Yellow
	 * control 'EN'=entrance 'EX'=exit points
	 */
	Queue<Car> streetQueue = new LinkedList<Car>();
	Queue<Car> avenueQueue = new LinkedList<Car>();
	//queue of cars waiting
	
	public static boolean addControlPoits(Set<Map.Entry<char[] ,Road>> set) {
		if(set == null)
			return false;
		//declaring and initializing street and avenue entrance and exit points
		System.out.println("Initializing Entrance and Exit Points");
		Road tempRoad;
		TrafficPoint tempPoint;
		for(Map.Entry<char[], Road> entry : set) {
			tempRoad = entry.getValue();
			if(tempRoad.getType() == 'S') {
				tempPoint = new TrafficPoint(tempRoad, null, new char[]{'E','N'});
				trafficPoints.put(tempPoint.pointID, tempPoint);
				tempPoint = new TrafficPoint(tempRoad, null, new char[]{'E','X'});
				trafficPoints.put(tempPoint.pointID, tempPoint);
			}
			else if(tempRoad.getType() == 'A') {
				tempPoint = new TrafficPoint(null, tempRoad, new char[]{'E','N'});
				trafficPoints.put(tempPoint.pointID, tempPoint);
				tempPoint = new TrafficPoint(null, tempRoad, new char[]{'E','X'});
				trafficPoints.put(tempPoint.pointID, tempPoint);
			}
		}
		System.out.println("Initializing Intersection points");
		for(Map.Entry<char[], Road> entry1 : set) {
			for(Map.Entry<char[], Road> entry2 : set) {
				if(entry1.getValue().getType() != entry2.getValue().getType()) {
					tempPoint = new TrafficPoint(entry1.getValue(), entry2.getValue(), 
						new char[]{'R','Y'});
					trafficPoints.put(tempPoint.getPointID(), tempPoint);
				}
			}
		}
		return true;
	}
	
	private TrafficPoint(Road street, Road avenue, char[] control) {
		char[] streetID = new char[]{'0','0','0','0'};
		char[] avenueID = new char[]{'0','0','0','0'};
		if(avenue == null) {						//initialize as street
			streetID = street.getRoadID();
		} else if(street == null) {					//initialize as avenue
			avenueID = avenue.getRoadID();
		}
		for(int i=0; i<pointID.length; i++){		//copying road IDs as traffic light ID
			if(i<4)
				this.pointID[i]=streetID[i];
			else
				this.pointID[i]=avenueID[i-4];
		}
		if(avenue == null) {			//initialize as street entrance or exit
			if(control[1] == 'N')
				this.pointID[0] = '1';
			else if(control[1] == 'X')
				this.pointID[0] = '2';
			this.xy[1] = street.getAccPos();
			//based on entrance, exit and direction position assigned
			if((street.getRoadDirection() == 'E' && control[1] == 'N') || 
					(street.getRoadDirection() == 'W' && control[1] == 'X'))
				this.xy[0] = Road.getXAccPos();
			else if((street.getRoadDirection() == 'E' && control[1] == 'X') || 
					(street.getRoadDirection() == 'W' && control[1] == 'N'))
				this.xy[0] = 0;
			this.roadDir[0] = street.getRoadDirection();
			this.roadDir[1] = this.roadDir[0];
		} else if(street == null) {		//initialize as avenue entrance or exit
			if(control[1] == 'N')
				this.pointID[4] = '1';
			else if(control[1] == 'X')
				this.pointID[4] = '2';
			this.xy[0] = avenue.getAccPos();
			if((avenue.getRoadDirection() == 'N' && control[1] == 'N') || 
					(avenue.getRoadDirection() == 'S' && control[1] == 'E'))
				this.xy[1] = 0;
			else if((avenue.getRoadDirection() == 'S' && control[1] == 'N') || 
					(avenue.getRoadDirection() == 'N' && control[1] == 'E'))
				this.xy[1] = Road.getYAccPos();
			this.roadDir[0] = avenue.getRoadDirection();
			this.roadDir[1] = this.roadDir[0];
		} else {						//initialize as intersection
			streetID = street.getRoadID();
			avenueID = avenue.getRoadID();
			this.xy[0] = avenue.getAccPos();
			this.xy[1] = street.getAccPos();
			this.roadDir[0] = street.getRoadDirection();
			this.roadDir[1] = avenue.getRoadDirection();
		}
		this.street = street;
		this.avenue = avenue;
		this.control = Arrays.copyOfRange(control, 0, 2);
		//System.out.print(this.xy[0]);
		//System.out.print("\t");
		//System.out.println(this.xy[1]);
	}
	
	public static Set<Map.Entry<char[] ,TrafficPoint>> getEntrySet() {
		return trafficPoints.entrySet();
	}
	
	public Road getStreet() {
		return street;
	}
	public Road getAvenue() {
		return avenue;
	}
	
	public char[] getPointID() {
		return pointID;
	}
	public char getStreetDir() {
		return roadDir[0];
	}
	public char getAvenueDir() {
		return roadDir[1];
	}
	public int getX() {
		return xy[0];
	}
	public int getY() {
		return xy[1];
	}
	public char getStreetControl() {
		return control[0];
	}
	public char getAvenueControl() {
		return control[1];
	}
	
	public boolean nextControl() {
		if(pointID[0] != '3' || pointID[0] != '4')		//not street or avenue
			return false;
		else if(control[0] == 'R') {
			if(control[1] == 'R')
				control[0] = 'G';
			else if(control[1] == 'G')
				control[1] = 'Y';
			else if(control[1] == 'Y')
				control = new char[]{'G','R'};
		} else if(control[0] == 'G') {
			control[0] = 'Y';
		} else if(control[0] == 'Y') {
			control = new char[]{'R','G'};
		} else
			control = new char[]{'R','R'};
		return true;
	}
}
