/* This class will be responsible for drawing the grid 
 * Layouting the streets, avenues, entry points
 * and traffic signals
 */

import java.awt.*;
import java.util.Map;

public class TrafficGrid extends Canvas implements Runnable {
	
	/**
	 * 
	 */
	private Grid grid;
	private static final long serialVersionUID = 1L;
	int carwidth=2, carlength=4;
	Thread gridPaint;
	
	public TrafficGrid(Configuration config, Grid grid) {
		this.grid = grid;
	}
	
	Image offscreen;
	Dimension offscreensize;
	Graphics offgraphics;
	
	public synchronized void paint(Graphics g) {
		Dimension d = getSize();
		if ((offscreen == null) || (d.width != offscreensize.width) || (d.height != offscreensize.height)) {
				//for window resizing
				offscreen = createImage(d.width, d.height);
				offscreensize = d;
				offgraphics = offscreen.getGraphics();
		}
		offgraphics.setColor(Color.black);
		offgraphics.fillRect(0, 0, d.width, d.height);
		paintRoad(offgraphics);
		paintLights(offgraphics);
		g.drawImage(offscreen, 0, 0, null);
	}
	
	public void paintRoad(Graphics g){
		Dimension d = getSize();
		Road tempRoad;
		for(Map.Entry<char[], Road> entry : grid.roadMap.entrySet()) {
			tempRoad = entry.getValue();
			if(tempRoad.getType() == 'S') {
				//Drawing streets
				g.setColor(Color.gray);
				g.fillRect(0, carlength*tempRoad.getAccPos()-3*carwidth, d.width, 6*carwidth);
				g.setColor(Color.WHITE);
				if(tempRoad.getRoadDirection() == 'E')
					g.fillRect(0, carlength*tempRoad.getAccPos()-3*carwidth, carwidth, 6*carwidth);
			} else if(tempRoad.getType() == 'A') {
				//Drawing avenues
				g.setColor(Color.gray);
				g.fillRect(carlength*tempRoad.getAccPos()-3*carwidth, 0, 6*carwidth, d.height);
				g.setColor(Color.WHITE);
				if(tempRoad.getRoadDirection() == 'N')
					g.fillRect(carlength*tempRoad.getAccPos()-3*carwidth, 0, 6*carwidth, carwidth);
			}
		}
		for(Map.Entry<char[], Road> entry : grid.roadMap.entrySet()) {
			tempRoad = entry.getValue();
			if(tempRoad.getType() == 'S') {
				//Drawing streets
				g.setColor(Color.yellow);
				g.drawLine(0, carlength*tempRoad.getAccPos()-carwidth, d.width, 
						carlength*tempRoad.getAccPos()-carwidth);
				g.drawLine(0, carlength*tempRoad.getAccPos()+carwidth, d.width, 
						carlength*tempRoad.getAccPos()+carwidth);
			} else if(tempRoad.getType() == 'A') {
				//Drawing avenues
				g.setColor(Color.yellow);
				g.drawLine(carlength*tempRoad.getAccPos()-carwidth, 0, 
						carlength*tempRoad.getAccPos()-carwidth, d.height);
				g.drawLine(carlength*tempRoad.getAccPos()+carwidth, 0, 
						carlength*tempRoad.getAccPos()+carwidth, d.height);
			}
		}
	}
	
	public void paintLights(Graphics g) {
		//draw traffic lights at intersections as green initial
		TrafficControl tempPoint;
		for(Map.Entry<char[], TrafficControl> entry : grid.trafficPoints.entrySet()) {
			tempPoint = entry.getValue();
			if(tempPoint.getStreetControl() != 'E') {
				switch(tempPoint.getAvenueControl()) {
					case 'R':	g.setColor(Color.red);
								break;
					case 'G':	g.setColor(Color.green);
								break;
					case 'Y':	g.setColor(Color.yellow);
								break;
				}
				if(tempPoint.getAvenueDir() == 'N') {
					g.fillRect(carlength*tempPoint.getX()-3*carwidth, 
							carlength*tempPoint.getY()-4*carwidth, 6*carwidth, carwidth);
				} else if(tempPoint.getAvenueDir() == 'S') {
					g.fillRect(carlength*tempPoint.getX()-3*carwidth, 
							carlength*tempPoint.getY()+3*carwidth, 6*carwidth, carwidth);
				}
				switch(tempPoint.getStreetControl()) {
					case 'R':	g.setColor(Color.red);
								break;
					case 'G':	g.setColor(Color.green);
								break;
					case 'Y':	g.setColor(Color.yellow);
								break;
				}
				if(tempPoint.getStreetDir() == 'E') {
					g.fillRect(carlength*tempPoint.getX()-4*carwidth, 
							carlength*tempPoint.getY()-3*carwidth, carwidth, 6*carwidth);
				} else if(tempPoint.getStreetDir() == 'W') {
					g.fillRect(carlength*tempPoint.getX()+3*carwidth, 
							carlength*tempPoint.getY()-3*carwidth, carwidth, 6*carwidth);
				}
			}
		}
	}
	
	public void run() {
		while (true) {
			repaint();
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				break;
			}
		}
	}
	
	public void start() {
		gridPaint = new Thread(this);
		gridPaint.start();
	}
	
	public void stop() {
		gridPaint.interrupt();
	}
}
