/* This class will be responsible for drawing the grid 
 * Layouting the streets, avenues, entry points
 * and traffic signals
 */

import java.awt.*;
import java.util.Arrays;
import java.util.Map;
import javax.swing.ImageIcon;

public class PaintGrid extends Canvas implements Runnable {
	
	private static final long serialVersionUID = 1L;
	private int CarLength = 6, CarWidth=3;
	private Thread gridPaint;
	private boolean isRunning = false;
	
	private Image northImg, southImg, eastImg, westImg;
	
	public PaintGrid(int CarLength, int CarWidth) {
		this.CarLength = CarLength;
		this.CarWidth = CarWidth;
		loadImages();
	}
	
	Image offscreen;
	Graphics offgraphics;
	
	private synchronized void relax() {
		TrafficPoint tempPoint;
		Car tempCar = null;
		int speed = 0;
		boolean wait = false;
		for(Map.Entry<char[], TrafficPoint> entry : TrafficPoint.getEntrySet()) {
			tempPoint = entry.getValue();
			//check if entrance point && road in front clear
			if(!tempPoint.emptyQueue()) {
				//see if a car is blocking entrance
				for(Map.Entry<char[], Car> entry2 : Car.getEntrySet()) {
					wait = tempPoint.distance(entry2.getValue()) < CarLength+2;
					//replace 2 with car clearance pixels from configuration
					if(wait) break;
				}
				if(!wait) {
					tempCar = tempPoint.Dequeue();
					tempCar.xy = Arrays.copyOfRange(tempPoint.xy, 0, 2);
					tempCar.setDirection(tempPoint.roadDir[0]);
					//direction same for entrance and exit points
					tempCar.nextPoint = (tempPoint.nextStreet == null)? 
							tempPoint.nextAvenue : tempPoint.nextStreet;
					tempCar.phase = 'M';
					//System.out.print(tempCar.carID);
					//System.out.print("\t");
					//System.out.println(tempCar.nextPoint.pointID);
				}
			}
			wait = false;
		}
		for(Map.Entry<char[], Car> entry : Car.getEntrySet()) {
			tempCar = entry.getValue();
			//System.out.print(tempCar.carID);
			for(Map.Entry<char[], Car> entry1 : Car.getEntrySet()) {
				//replace constant with clearance
				//System.out.print("\t"+tempCar.distance(entry1.getValue()));
				wait = tempCar.distance(entry1.getValue()) < CarLength+2;
				if(wait && entry1.getValue().phase == 'M') break;
			}
			//System.out.println("\n________________________________________");
			//wait = false;
			if(!wait) {
				speed = 5;
				if(!tempCar.xy.equals(new int[]{-1, -1})) {
					if(tempCar.dir == 'N')
						tempCar.moveXY(new int[]{0, speed});
					else if(tempCar.dir == 'S')
						tempCar.moveXY(new int[]{0, -1*speed});
					else if(tempCar.dir == 'E')
						tempCar.moveXY(new int[]{-1*speed, 0});
					else if(tempCar.dir == 'W')
						tempCar.moveXY(new int[]{speed, 0});
				}
			}
			wait = false;
		}
		repaint();
	}
	
	public synchronized void paint(Graphics g) {
		Dimension d = new Dimension(Road.xAccumulativePosition, 
				Road.yAccumulativePosition);
		if (offscreen == null) {
				//for window resizing
				offscreen = createImage(d.width, d.height);
				offgraphics = offscreen.getGraphics();
		}
		offgraphics.setColor(Color.black);
		offgraphics.fillRect(0, 0, d.width, d.height);
		paintRoad(offgraphics);
		paintLights(offgraphics);
		paintCars(offgraphics);
		g.drawImage(offscreen, 0, 0, null);
	}
	
	private void paintRoad(Graphics g){
		Dimension d = getSize();
		Road tempRoad;
		for(Map.Entry<char[], Road> entry : Road.getEntrySet()) {
			tempRoad = entry.getValue();
			if(tempRoad.roadType == 'S') {
				//Drawing streets
				g.setColor(Color.gray);
				g.fillRect(0, tempRoad.accumulativePosition-3*CarWidth, 
						d.width, 6*CarWidth);
				g.setColor(Color.WHITE);
				if(tempRoad.roadDir == 'E')
					g.drawImage(eastImg, Road.xAccumulativePosition-30, 
							tempRoad.accumulativePosition-8, null);
				else if(tempRoad.roadDir == 'W')
					g.drawImage(westImg, 0, tempRoad.accumulativePosition-8, null);
			} else if(tempRoad.roadType == 'A') {
				//Drawing avenues
				g.setColor(Color.gray);
				g.fillRect(tempRoad.accumulativePosition-3*CarWidth, 0, 
						6*CarWidth, d.height);
				g.setColor(Color.WHITE);
				if(tempRoad.roadDir == 'N')
					g.drawImage(northImg, tempRoad.accumulativePosition-8, 
							0, null);
				else if(tempRoad.roadDir == 'S')
					g.drawImage(southImg, tempRoad.accumulativePosition-8, 
							Road.yAccumulativePosition-30, null);
			}
		}
		for(Map.Entry<char[], Road> entry : Road.getEntrySet()) {
			tempRoad = entry.getValue();
			if(tempRoad.roadType == 'S') {
				//Drawing streets
				g.setColor(Color.yellow);
				g.drawLine(0, tempRoad.accumulativePosition-CarWidth, d.width, 
						tempRoad.accumulativePosition-CarWidth);
				g.drawLine(0, tempRoad.accumulativePosition+CarWidth, d.width, 
						tempRoad.accumulativePosition+CarWidth);
			} else if(tempRoad.roadType == 'A') {
				//Drawing avenues
				g.setColor(Color.yellow);
				g.drawLine(tempRoad.accumulativePosition-CarWidth, 0, 
						tempRoad.accumulativePosition-CarWidth, d.height);
				g.drawLine(tempRoad.accumulativePosition+CarWidth, 0, 
						tempRoad.accumulativePosition+CarWidth, d.height);
			}
		}
	}
	
	private void paintLights(Graphics g) {
		//draw traffic lights at intersections as green initial
		TrafficPoint tempPoint;
		for(Map.Entry<char[], TrafficPoint> entry : TrafficPoint.getEntrySet()) {
			tempPoint = entry.getValue();
			if(tempPoint.control[0] != 'E') {		//not entrance nor exit
				switch(tempPoint.control[1]) {
					case 'R':	g.setColor(Color.red);
								break;
					case 'G':	g.setColor(Color.green);
								break;
					case 'Y':	g.setColor(Color.yellow);
								break;
				}
				if(tempPoint.roadDir[1] == 'N') {
					g.fillRect(tempPoint.xy[0]-3*CarWidth, 
							tempPoint.xy[1]-4*CarWidth, 6*CarWidth, CarWidth);
				} else if(tempPoint.roadDir[1] == 'S') {
					g.fillRect(tempPoint.xy[0]-3*CarWidth, 
							tempPoint.xy[1]+3*CarWidth, 6*CarWidth, CarWidth);
				}
				switch(tempPoint.control[0]) {
					case 'R':	g.setColor(Color.red);
								break;
					case 'G':	g.setColor(Color.green);
								break;
					case 'Y':	g.setColor(Color.yellow);
								break;
				}
				if(tempPoint.roadDir[0] == 'E') {
					g.fillRect(tempPoint.xy[0]+3*CarWidth, 
							tempPoint.xy[1]-3*CarWidth, CarWidth, 6*CarWidth);
				} else if(tempPoint.roadDir[0] == 'W') {
					g.fillRect(tempPoint.xy[0]-4*CarWidth, 
							tempPoint.xy[1]-3*CarWidth, CarWidth, 6*CarWidth);
				}
			}
		}
	}
	
	private void paintCars(Graphics g) {
		g.setColor(Color.cyan);
		Car tempCar;
		for(Map.Entry<char[], Car> entry : Car.getEntrySet()) {
			tempCar = entry.getValue();
			if(!tempCar.xy.equals(new int[]{-1, -1})) {
				g.fillRect(tempCar.xy[0]-4, 
						tempCar.xy[1]-4, CarLength, CarLength);
			}
		}
	}
	
	private void loadImages() {
		northImg = new ImageIcon("images/north.png").getImage();
        southImg = new ImageIcon("images/south.png").getImage();
        eastImg = new ImageIcon("images/east.png").getImage();
        westImg = new ImageIcon("images/west.png").getImage();
	}
	
	@Override
	public void run() {
		while (isRunning) {
			relax();
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				break;
			}
		}
	}
	
	public void start() {
		gridPaint = new Thread(this);
		isRunning = true;
		gridPaint.start();
	}
	
	public void stop() {
		gridPaint.interrupt();
		isRunning = false;
	}
}
