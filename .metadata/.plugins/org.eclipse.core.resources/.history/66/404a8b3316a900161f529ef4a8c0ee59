/* This class will be responsible for drawing the grid 
 * Layouting the streets, avenues, entry points
 * and traffic signals
 */

import java.awt.*;
import java.util.Arrays;
import java.util.Map;
import javax.swing.ImageIcon;

public class PaintGrid extends Canvas implements Runnable {
	
	private static final long serialVersionUID = 1L;
	private Thread gridPaint;
	private boolean isRunning = false;
	
	private Image northImg, southImg, eastImg, westImg;
	
	public PaintGrid() {
		loadImages();
	}
	
	Image offscreen;
	Graphics offgraphics;
	
	private synchronized void relax() {
		TrafficPoint tempPoint;
		Car tempCar = null;
		int distance = Integer.MAX_VALUE;
		int tempDistance;
		boolean wait = false;
		for(Map.Entry<char[], Car> entry : Car.getEntrySet()) {
			if(entry.getValue().phase != 'Q') continue;		//not queued car
			tempCar = entry.getValue();
			tempPoint = tempCar.entrancePoint;
			//check if entrance point && road in front clear
			for(Map.Entry<char[], Car> entry2 : Car.getEntrySet()) {
				if(entry2.getValue().phase != 'M') continue;
				distance = tempPoint.distance(entry2.getValue());
				wait = Math.abs(distance) < (Frame.carLength+2*Frame.Clearance);
				if(wait) {
					break;
				}
			}
			if(!wait) {
				if(tempPoint.roadDir[0] == 'N' || tempPoint.roadDir[0] =='S')
					tempPoint.comingCars[1]--;
				else if(tempPoint.roadDir[0] == 'E' || tempPoint.roadDir[0] == 'W')
					tempPoint.comingCars[0]--;
				/*System.out.print(tempCar.carID);
				System.out.println(" car moving");*/
				if(tempCar.lane == 'M')
					tempCar.xy = Arrays.copyOfRange(tempPoint.sectors[1][1], 0, 2);
				else if((tempPoint.roadDir[0] == 'E' && tempCar.lane == 'R') || 
						(tempPoint.roadDir[0] == 'W' && tempCar.lane == 'L'))
					tempCar.xy = Arrays.copyOfRange(tempPoint.sectors[0][0], 0, 2);
				else if((tempPoint.roadDir[0] == 'E' && tempCar.lane == 'L') || 
						(tempPoint.roadDir[0] == 'W' && tempCar.lane == 'R'))
					tempCar.xy = Arrays.copyOfRange(tempPoint.sectors[2][0], 0, 2);
				else if((tempPoint.roadDir[0] == 'N' && tempCar.lane == 'R') || 
						(tempPoint.roadDir[0] == 'S' && tempCar.lane == 'L'))
					tempCar.xy = Arrays.copyOfRange(tempPoint.sectors[0][0], 0, 2);
				else if((tempPoint.roadDir[0] == 'N' && tempCar.lane == 'L') ||
						(tempPoint.roadDir[0] == 'S' && tempCar.lane == 'R'))
					tempCar.xy = Arrays.copyOfRange(tempPoint.sectors[0][2], 0, 2);
				tempCar.dir = tempPoint.roadDir[0];
				//direction same for entrance and exit points
				tempCar.nextPoint = (tempPoint.nextStreet == null)? 
						tempPoint.nextAvenue : tempPoint.nextStreet;
				//tempCar.phase = 'M'; fixed in enterGrid()
				tempCar.enterGrid();
			}
			
			
			
			if(!tempPoint.emptyQueue()) {
				//see if a car is blocking entrance
				
				
			}
			wait = false;
		}
		for(Map.Entry<char[], Car> entry : Car.getEntrySet()) {
			if(entry.getValue().phase != 'M') continue;		//if car not moving
			tempCar = entry.getValue();
			if(tempCar.dir == 'N' || tempCar.dir == 'W')
				distance = Integer.MIN_VALUE;
			else if(tempCar.dir == 'S' || tempCar.dir == 'E')
				distance = Integer.MAX_VALUE;
			for(Map.Entry<char[], Car> entry1 : Car.getEntrySet()) {
				if(tempCar == entry1.getValue()) continue;
				if(entry1.getValue().phase != 'M') continue;	//if car not moving
				if(tempCar.road != entry1.getValue().road) continue;
				
				tempDistance = tempCar.distance(entry1.getValue());
				/*System.out.print(tempCar.carID);
				System.out.print("\t");
				System.out.print(entry1.getValue().carID);
				System.out.print("\t"+distance+"\t"+tempDistance);*/
				if(tempCar.dir == 'N' || tempCar.dir == 'W') {			//negative directions
					if(tempDistance < 0)
						distance = Math.max(distance, tempDistance);
				} else if(tempCar.dir == 'S' || tempCar.dir == 'E') {	//positive directions
					if(tempDistance > 0)
						distance = Math.min(distance, tempDistance);
				}
				//System.out.println("\t"+distance);
			}
			//Making distance = 0 if it equals Math.abs(Integer.MIN_VALUE)
			distance = (distance==Integer.MIN_VALUE)? Integer.MAX_VALUE:Math.abs(distance);
			tempCar.moveXY(distance);
		}
		repaint();
		/*wait = false;
		for(Map.Entry<char[], Car> entry : Car.getEntrySet()) {
			wait = entry.getValue().phase != 'S';
			if(wait) break;
		}
		if (!wait && Car.carCount != 0) {
			this.stop();
			System.out.println("\nExecution stopped");
			return;
		}*/
	}
	
	public synchronized void paint(Graphics g) {
		Dimension d = new Dimension(Road.xAccumulativePosition, 
				Road.yAccumulativePosition);
		if (offscreen == null) {
				//for window resizing
				offscreen = createImage(d.width, d.height);
				offgraphics = offscreen.getGraphics();
		}
		offgraphics.setColor(Color.black);
		offgraphics.fillRect(0, 0, d.width, d.height);
		paintRoad(offgraphics);
		paintLights(offgraphics);
		paintCars(offgraphics);
		g.drawImage(offscreen, 0, 0, null);
	}
	
	private void paintRoad(Graphics g){
		Dimension d = getSize();
		Road tempRoad;
		int roadCoord = 1+(int)(1.5*(Frame.carWidth+Frame.Clearance));
		int roadWidth = 2+3*(Frame.carWidth+Frame.Clearance);
		for(Map.Entry<char[], Road> entry : Road.getEntrySet()) {
			tempRoad = entry.getValue();
			if(tempRoad.roadType == 'S') {
				//Drawing streets
				g.setColor(Color.gray);
				g.fillRect(0, tempRoad.sectors[1] - roadCoord, d.width, roadWidth);
				g.setColor(Color.WHITE);
				if(tempRoad.roadDir == 'E')
					g.drawImage(eastImg, Road.xAccumulativePosition-30, 
							tempRoad.sectors[1] -8, null);
				else if(tempRoad.roadDir == 'W')
					g.drawImage(westImg, 0, tempRoad.sectors[1]-8, null);
			} else if(tempRoad.roadType == 'A') {
				//Drawing avenues
				g.setColor(Color.gray);
				g.fillRect(tempRoad.sectors[1] - roadCoord, 0, roadWidth, d.height);
				g.setColor(Color.WHITE);
				if(tempRoad.roadDir == 'N')
					g.drawImage(northImg, tempRoad.sectors[1]-8, 
							0, null);
				else if(tempRoad.roadDir == 'S')
					g.drawImage(southImg, tempRoad.sectors[1]-8, 
							Road.yAccumulativePosition-30, null);
			}
		}
		int yellowLine = 1 + (int)(0.5*(Frame.carWidth+Frame.Clearance));
		for(Map.Entry<char[], Road> entry : Road.getEntrySet()) {
			tempRoad = entry.getValue();
			if(tempRoad.roadType == 'S') {
				//Drawing streets
				g.setColor(Color.yellow);
				g.drawLine(0, tempRoad.sectors[1]-yellowLine, d.width, 
						tempRoad.sectors[1]-yellowLine);
				g.drawLine(0, tempRoad.sectors[1]+yellowLine, d.width, 
						tempRoad.sectors[1]+yellowLine);
			} else if(tempRoad.roadType == 'A') {
				//Drawing avenues
				g.setColor(Color.yellow);
				g.drawLine(tempRoad.sectors[1]-yellowLine, 0, 
						tempRoad.sectors[1]-yellowLine, d.height);
				g.drawLine(tempRoad.sectors[1]+yellowLine, 0, 
						tempRoad.sectors[1]+yellowLine, d.height);
			}
		}
	}
	
	private void paintLights(Graphics g) {
		//draw traffic lights at intersections as green initial
		TrafficPoint tempPoint;
		for(Map.Entry<char[], TrafficPoint> entry : TrafficPoint.getEntrySet()) {
			tempPoint = entry.getValue();
			if(tempPoint.control[0] != 'E') {		//not entrance nor exit
				switch(tempPoint.control[1]) {
					case 'R':	g.setColor(Color.red);
								break;
					case 'G':	g.setColor(Color.green);
								break;
					case 'Y':	g.setColor(Color.yellow);
								break;
				}
				if(tempPoint.roadDir[1] == 'N') {
					g.fillRect(tempPoint.sectors[1][1][0]-3*Frame.carWidth, 
							tempPoint.sectors[1][1][1]-4*Frame.carWidth, 
							6*Frame.carWidth, Frame.carWidth);
				} else if(tempPoint.roadDir[1] == 'S') {
					g.fillRect(tempPoint.sectors[1][1][0]-3*Frame.carWidth, 
							tempPoint.sectors[1][1][1]+3*Frame.carWidth, 
							6*Frame.carWidth, Frame.carWidth);
				}
				switch(tempPoint.control[0]) {
					case 'R':	g.setColor(Color.red);
								break;
					case 'G':	g.setColor(Color.green);
								break;
					case 'Y':	g.setColor(Color.yellow);
								break;
				}
				if(tempPoint.roadDir[0] == 'E') {
					g.fillRect(tempPoint.sectors[1][1][0]+3*Frame.carWidth, 
							tempPoint.sectors[1][1][1]-3*Frame.carWidth, 
							Frame.carWidth, 6*Frame.carWidth);
				} else if(tempPoint.roadDir[0] == 'W') {
					g.fillRect(tempPoint.sectors[1][1][0]-4*Frame.carWidth, 
							tempPoint.sectors[1][1][1]-3*Frame.carWidth, 
							Frame.carWidth, 6*Frame.carWidth);
				}
			}
		}
	}
	
	private void paintCars(Graphics g) {
		
		Car tempCar;
		int HLength = 1+(int)(Frame.carLength/2);
		int HWidth = 1+(int)(0.5*(Frame.carWidth-Frame.Clearance));
		for(Map.Entry<char[], Car> entry : Car.getEntrySet()) {
			if(entry.getValue().phase != 'M') continue;
			tempCar = entry.getValue();
			switch(tempCar.remainingTurns) {
			case 0: g.setColor(new Color(0, 255, 255));
					break;
			case 1: g.setColor(new Color(0, 255, 127));
					break;
			case 2: g.setColor(new Color(0, 255, 0));
					break;
			}
			if(tempCar.dir == 'E' || tempCar.dir == 'W')
				g.fillRect(tempCar.xy[0]-HLength, tempCar.xy[1]-HWidth, 
						Frame.carLength, Frame.carWidth);
			else if(tempCar.dir == 'N' || tempCar.dir == 'S')
				g.fillRect(tempCar.xy[0]-HWidth, tempCar.xy[1]-HLength, 
						Frame.carWidth, Frame.carLength);
		}
	}
	
	private void loadImages() {
		northImg = new ImageIcon("images/north.png").getImage();
        southImg = new ImageIcon("images/south.png").getImage();
        eastImg = new ImageIcon("images/east.png").getImage();
        westImg = new ImageIcon("images/west.png").getImage();
	}
	
	@Override
	public void run() {
		while (isRunning) {
			relax();
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				break;
			}
		}
	}
	
	public void start() {
		gridPaint = new Thread(this);
		isRunning = true;
		gridPaint.start();
	}
	
	public void stop() {
		gridPaint.interrupt();
		isRunning = false;
	}
}
